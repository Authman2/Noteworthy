{"version":3,"sources":["vdom/createElement.js","util.js","vdom/render.js","vdom/patch.js","observable.js","router.js","validations.js","index.js"],"names":["createElement","type","children","props","exports","setAttributes","$element","key","value","startsWith","event","slice","toLowerCase","__mosaicHandlers","removeEventListener","addEventListener","Object","assign","style","__mosaicKey","setAttribute","traverseVDomTree","head","start","array","comparator","action","i","push","cloneFunction","that","f","apply","arguments","hasOwnProperty","deepClone","from","out","create","call","bind","isHTMLElement","obj","HTMLElement","e","nodeType","ownerDocument","viewToDOM","input","caller","replaced","dataProp","data","propName","propVal","re","RegExp","replace","DOMParser","parseFromString","body","firstChild","render","vnode","$parent","instance","mount","$el","replaceWith","appendChild","document","createTextNode","__isMosaic","Mosaic","view","$e","$dom","concat","prop","Error","patch","parentNode","replaceChild","Text","textContent","$node","element","nodeName","toUpperCase","n","pool","active","activeElement","childNodes","map","child","index","__mosaicInstance","willDestroy","parent","remove","attr","attributes","removeAttribute","name","focus","Observable","observingObject","willChange","didChange","Proxy","get","object","receiver","Reflect","set","old","defineProperty","descriptor","deleteProperty","Router","currentRoute","routes","__isRouter","window","onpopstate","oldURL","location","pathname","oldRouteObj","find","r","Array","isArray","path","includes","mosaic","paint","prototype","addRoute","send","to","routeObj","history","pushState","origin","back","forward","href","substring","lastIndexOf","findInvalidOptions","options","contains","router","actions","created","willUpdate","updated","willDestory","MosaicOptions","Function","invalids","undefined","_tempData","htree","oldData","link","removeChild","_data","length","constructor","$ndom","h"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["const createElement = function(type, props = {}, ...children) {\n    return {\n        type: type,\n        props: props || {},\n        children,\n    };\n}\nexports.createElement = createElement;","/** Sets the attributes on the HTML elements that were mounted by the virtual DOM. */\nconst setAttributes = function($element, key, value, instance = null) {\n    // 1.) Function handler for dom element.\n    if(typeof value === 'function' && key.startsWith('on')) {\n        const event = key.slice(2).toLowerCase();\n        $element.__mosaicHandlers = $element.__mosaicHandlers || {};\n        $element.removeEventListener(event, $element.__mosaicHandlers[event]);\n        \n        $element.__mosaicHandlers[event] = value;\n        $element.addEventListener(event, $element.__mosaicHandlers[event]);\n    }\n    // 2.) Particular types of attributes.\n    else if(key === 'checked' || key === 'value' || key === 'className') {\n        $element[key] = value;\n    }\n    // 3.) Style property.\n    else if(key === 'style') {\n        if(typeof value === 'object') Object.assign($element.style, value);\n        else if(typeof value === 'string') $element[key] = value;\n    }\n    // 5.) Support the key property for more efficient rendering.\n    else if(key === 'key') {\n        $element.__mosaicKey = value;\n    }\n    // 6.) Value is a not an object nor a function, so anything else basically.\n    else if(typeof value !== 'object' && typeof value !== 'function') {\n        $element.setAttribute(key, value);\n    }\n}\n\n/** Start with a particular VNode and traverse the entire tree and only return the ones that match\n* the comparator.\n* @param {Object} head The absolute parent VNode.\n* @param {Object} start The starting VNode.\n* @param {Array} array The final array to return.\n* @param {Function} comparator The compare function. \n* @param {Function} action The action to take when the comparator is true. */\nconst traverseVDomTree = function(head, start, array, comparator, action) {\n\t// console.log(\"DOM: \", start);\n\tif(comparator(head, start, array) === true) {\n\t\tif(action) action(head, start, array);\n\t\tarray.push(start);\n\t}\n\n\tfor(var i in start.children) {\n\t\ttraverseVDomTree(head, start.children[i], array, comparator, action);\n\t}\n\treturn array;\n}\n\n/** Clones a function. */\nconst cloneFunction = function() {\n    var that = this;\n    var f = function() { return that.apply(this, arguments); };\n    for(var key in this) {\n        if (this.hasOwnProperty(key)) {\n            f[key] = this[key];\n        }\n    }\n    return f;\n};\n\n/** Does a deep clone of an object, also cloning its children.\n * @param {Object} from The input object to copy from.\n */\nconst deepClone = function(from) {\n\tlet out = Object.create({});\n\tif(typeof from === 'function') {\n\t\treturn cloneFunction.call(from);\n\t}\n\tfor(var i in from) {\n\t\tif(from.hasOwnProperty(i)) {\n\t\t\tif(typeof from[i] === 'object') {\n\t\t\t\t// if(from[i].__IS_PROXY) {\n\t\t\t\t// \tlet ulo = Object.assign({}, from[i].__TARGET);\n\t\t\t\t// \tlet nProx = new Observable(ulo, () => from[i].willChange, () => from[i].didChange);\n\t\t\t\t// \tout[i] = nProx;\n\t\t\t\t// } else {\n\t\t\t\t\tout[i] = Object.assign({}, deepClone(from[i]));\n\t\t\t\t// }\n\t\t\t}\n\t\t\telse if(typeof from[i] === 'function') {\n\t\t\t\tout[i] = from[i].bind(out);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout[i] = from[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\n/** Returns whether or not an object is an HTML element. */\nfunction isHTMLElement(obj) {\n    try { return obj instanceof HTMLElement; }\n    catch(e){\n      return (typeof obj === \"object\") && (obj.nodeType === 1) && (typeof obj.style === \"object\") &&\n        (typeof obj.ownerDocument ===\"object\");\n    }\n}\n\n/** Converts an html string into actual DOM elements. If the view function is passed in, it will\n* just be returned.\n* @param {String} input The HTML string. */\nconst viewToDOM = function(input, caller) {\n    if(typeof input === 'function') return input.call(caller);\n\n    var replaced = input;\n    for(var dataProp in caller.data) {\n        let propName = dataProp;\n        let propVal = caller.data[dataProp];\n        let re = new RegExp('{{[ ]*this.data.' + propName + '[ ]*}}', \"gim\");\n        let nstring = input.replace(re, propVal);\n        replaced = nstring;\n    }\n    let parser = new DOMParser();\n    let $element = parser.parseFromString(replaced, 'text/html').body.firstChild;\n    return $element;\n}\n\nexports.setAttributes = setAttributes;\nexports.traverseVDomTree = traverseVDomTree;\nexports.deepClone = deepClone;\nexports.isHTMLElement = isHTMLElement;\nexports.viewToDOM = viewToDOM;","import { Mosaic } from '../index';\nimport { setAttributes, isHTMLElement } from '../util';\n\nconst render = function(vnode, $parent = null, instance = null, replace = false) {\n    const mount = $parent ? ($el => (replace ? $parent.replaceWith($el) : $parent.appendChild($el))) : ($el => $el);\n\n    // 1.) Primitive types.\n    if(typeof vnode === 'string' || typeof vnode === 'number') {\n        let $e = document.createTextNode(typeof vnode === 'boolean' ? '' : vnode);\n        return mount($e);\n    }\n    // 2.) A Mosaic component.\n    else if(typeof vnode === 'object' && typeof vnode.type === 'object' && vnode.type.__isMosaic === true) {\n        return Mosaic.view(vnode, $parent);\n    }\n    // 3.) If it is already a dom element, just return it!\n    else if(isHTMLElement(vnode)) {\n        return mount(vnode);\n    }\n    // 4.) Handle child components and attributes.\n    else if(typeof vnode === 'object' && typeof vnode.type === 'string') {\n        const $e = document.createElement(vnode.type);\n        const $dom = mount($e);\n        for(var child of [].concat(...vnode.children)) render(child, $dom, instance);\n        for(var prop in vnode.props) setAttributes($dom, prop, vnode.props[prop], instance);\n        return $dom;\n    }\n    // 5.) Otherwise, throw an error.\n    else {\n        throw new Error(`Invalid Virtual DOM Node: ${vnode}.`);\n    }\n}\nexports.render = render;","import { Mosaic } from '../index';\nimport { render } from './render';\nimport { setAttributes, isHTMLElement, viewToDOM } from '../util';\n\nconst patch = function($dom, vnode, $parent = $dom.parentNode, instance = null) {\n    const replace = $parent ? ($el => { $parent.replaceChild($el, $dom); return $el }) : ($el => $el);\n    // console.log($dom, vnode);\n\n    // 1.) Patch the differences of a Mosaic type.\n    if(typeof vnode === 'object' && typeof vnode.type === 'object' && vnode.type.__isMosaic === true) {\n        return Mosaic.patch($dom, vnode, $parent);\n    }\n    // 2.) Compare plain text nodes.\n    else if(typeof vnode !== 'object' && $dom instanceof Text) {\n        return ($dom.textContent !== vnode) ? replace(render(vnode, $parent, instance)) : $dom;\n    }\n    // 3.) If it is an HTML element, just replace the dom element.\n    else if(isHTMLElement(vnode)) {\n        let $node = replace(vnode);\n        instance.element = $node;\n        return $node;\n    }\n    // 4.) If one is an object and one is text, just replace completely.\n    else if(typeof vnode === 'object' && $dom instanceof Text) {\n        return replace(render(vnode, $parent, instance));\n    }\n    // 5.) One is an object and the tags are different, so replace completely.\n    else if(typeof vnode === 'object' && (vnode.type && !vnode.type.__isMosaic) && $dom.nodeName !== vnode.type.toUpperCase()) {\n        let n = replace(render(vnode, $parent, instance));\n        return n;\n    }\n    // 6.) If they are objects and their tags are equal, patch their children recursively.\n    else if(typeof vnode === 'object' && $dom.nodeName === vnode.type.toUpperCase()) {\n        const pool = {};\n        const active = document.activeElement;\n\n        [].concat(...$dom.childNodes).map((child, index) => {\n            const key = child.__mosaicKey || `__index_${index}`;\n            pool[key] = child;\n        });\n        [].concat(...vnode.children).map((child, index) => {\n            const key = child.props && child.props.key || `__index_${index}`;\n            var $node;\n\n            if(pool[key]) $node = patch(pool[key], child)\n            else $node = render(child, $dom, instance);\n\n            $dom.appendChild($node);\n            delete pool[key];\n        });\n\n        // Unmount the component and call the lifecycle function.\n        for(const key in pool) {\n            const instance = pool[key].__mosaicInstance;\n            if(instance && instance.willDestroy) instance.willDestroy();\n\n            // Don't forget to remove references to parents!!\n            let parent = instance.parent || null;\n            if(parent) {\n                for(let i in parent) {\n                    let property = parent[i];\n                    if(property === instance) {\n                        delete parent[i];\n                    }\n                }\n            }\n            pool[key].remove();\n        }\n\n        // Remove and reset the necessary attributes.\n        for(var attr in $dom.attributes) $dom.removeAttribute(attr.name);\n        for(var prop in vnode.props) setAttributes($dom, prop, vnode.props[prop], vnode);\n        active.focus();\n        \n        // Return the real dom node.\n        return $dom;\n    }\n}\n\nexports.patch = patch;","/** Basically an object that can perform a certain function when a property changes. \n* @param {Object} observingObject The object to look for changes in.. */\nconst Observable = function(observingObject, willChange, didChange) {\n    const Handler = {\n        get(object, name, receiver) {\n            if(name === '__TARGET') { return Object.assign({}, observingObject); };\n            if(name === '__IS_PROXY') { return true };\n\n            return Reflect.get(object, name, receiver);\n        },\n        set(object, name, value) {\n            // About to update.\n            let old = Object.assign({}, observingObject);\n            if(willChange) willChange(old);\n            \n            // Make changes.\n            object[name] = value;\n            \n            // Did update.\n            if(didChange) didChange(object);\n\n            return Reflect.set(object, name, value);\n        },\n        defineProperty(object, name, descriptor) {\n            didChange(object);\n            return Reflect.defineProperty(object, name, descriptor);\n        },\n        deleteProperty(object, name) {\n            didChange(object);\n            return Reflect.deleteProperty(object, name);\n        }\n    };\n    return new Proxy(observingObject, Handler);\n}\n\nexports.Observable = Observable;","import { Mosaic } from './index';\n\n/** A basic routing solution for Mosaic apps. */\nconst Router = function() {\n    this.currentRoute = '/';\n    this.routes = [];\n    this.__isRouter = true;\n\n    // Setup the 'pop' url state.\n    window.onpopstate = () => {\n        let oldURL = window.location.pathname;\n        let oldRouteObj = this.routes.find(r => {\n            if(Array.isArray(r.path)) return r.path.includes(oldURL);\n            else return r.path === oldURL;\n        });\n        if(oldRouteObj) oldRouteObj.mosaic.paint();\n    }\n}\n\n/** Adds a new route to the Router.\n* @param {String | Array} path The path, or array of paths, that this route will match.\n* @param {Mosaic} mosaic The mosaic to display at this route. */\nRouter.prototype.addRoute = function({ path, mosaic }) {\n    if(typeof path !== 'string' && !Array.isArray(path)) {\n        throw new Error(`Mosaic.Router requires a \"path\" proeprty and a \"mosaic\" property for each route. There \n        must be exactly one default route with the path of \\'/\\'`);\n    }\n    if(typeof mosaic !== 'object' && !mosaic.__isMosaic) {\n        throw new Error(`Mosaic.Router requires a \"path\" proeprty and a \"mosaic\" property for each route. There \n        must be exactly one default route with the path of \\'/\\'`);\n    }\n\n    this.routes.push({ path, mosaic });\n}\n\n/** Function to send the app to a different route.\n* @param {String} to The path to point the router to. Must already exist in the router at initialization. */\nRouter.prototype.send = function(to) {\n    this.currentRoute = to;\n\n    // Get the route at the path.\n    let routeObj = this.routes.find(r => {\n        if(Array.isArray(r.path)) return r.path.includes(to);\n        else return r.path === to;\n    });\n\n    // Go to that url and paint the mosaic.\n    if(routeObj) {\n        window.history.pushState({}, this.currentRoute, window.location.origin + this.currentRoute);\n        routeObj.mosaic.paint();\n    } else {\n        throw new Error(`There was no route defined for ${this.currentRoute}`);\n    }\n}\n\n/** A function to send this router back one page. */\nRouter.prototype.back = function() {\n    window.history.back();\n}\n\n/** A function to send this router forward one page. */\nRouter.prototype.back = function() {\n    window.history.forward();\n}\n\n/** The paint function for the Mosaic Router. Performs the same function as the paint function for Mosaic\n* components, but handles painting all components labeled as routes. */\nRouter.prototype.paint = function() {\n    let path = this.currentRoute;\n\n    // If the current url at run time is different than what it was set to, change it.\n    if(window.location.origin !== path) {\n        this.currentRoute = window.location.href.substring(window.location.href.lastIndexOf('/'));\n    }\n    \n    this.send(this.currentRoute);\n}\n\nexports.Router = Router;","import { isHTMLElement } from './util';\n\n/** Looks at a Mosaic's configuration options and returns undefined if there is nothing wrong, and\n * returns a descriptor sentence if something is wrong.\n * @param {MosaicOptions} options The config options.\n * @returns {undefined} If there is nothing wrong with the input options.\n * @returns {String} describing the problem.\n */\nconst findInvalidOptions = function(options) {\n    // Element\n    if(options.element && (!isHTMLElement(options.element) || !document.contains(options.element))) {\n        return `The Mosaic could not be created because the \"element\" property is either not an HTML DOM \n        element or it does not already exist in the DOM. Make sure that the \"element\" property is an already \n        existing DOM element such as \"document.body\" or a div with the id of 'root' for example.`;\n    }\n\n    // Router\n    if(options.router && !options.router.__isRouter) {\n        return `The router property must be an instance of Mosaic.Router.`;\n    }\n\n    // Data\n    if(options.data && typeof options.data !== 'object') {\n        return `The data property of a Mosaic must be defined as a plain, JavaScript object.`;\n    }\n\n    // View\n    if(!options.view) {\n        return `View is a required property of Mosaic components.`\n    }\n    if(typeof options.view !== 'function' && typeof options.view !== 'string') {\n        return `The view property must either be a function that returns JSX code, an h-tree, a string representation\n        of an HTML tree, or the path to an HTML file.`;\n    }\n\n    // Actions\n    if(options.actions && typeof options.actions !== 'object') {\n        return `Actions must be defined as an object, where each entry is a function.`;\n    }\n\n    // Lifecycle\n    if((options.created && typeof options.created !== 'function')) {\n        return `All lifecycle methods (created, willUpdate, updated, and willDestroy) must be\n        function types.`;\n    }\n    if(options.willUpdate && typeof options.willUpdate !== 'function') {\n        return `All lifecycle methods (created, willUpdate, updated, and willDestroy) must be\n        function types.`;\n    }\n    if(options.updated && typeof options.updated !== 'function') {\n        return `All lifecycle methods (created, willUpdate, updated, and willDestroy) must be\n        function types.`;\n    }\n    if(options.willDestory && typeof options.willDestory !== 'function') {\n        return `All lifecycle methods (created, willUpdate, updated, and willDestroy) must be\n        function types.`;\n    }\n\n    return undefined;\n}\n\nexports.isHTMLElement = isHTMLElement;\nexports.findInvalidOptions = findInvalidOptions;","import { createElement } from './vdom/createElement';\nimport { render } from './vdom/render';\nimport { patch } from './vdom/patch';\nimport { Observable } from './observable';\nimport { Router } from './router';\nimport { isHTMLElement, findInvalidOptions } from './validations';\nimport { viewToDOM } from './util';\n\n/** The configuration options for a Mosaic component. */\nconst MosaicOptions = {\n    /** The HTML element to inject this Mosaic component into. */\n    element: HTMLElement,\n\n    /** The optional router to use for this Mosaic app. */\n    router: Router,\n\n    /** The state of this component. */\n    data: Object,\n\n    /** The view that will be rendered on the screen. */\n    view: Function,\n\n    /** The actions that can be used on this Mosaic component. */\n    actions: Object,\n\n    /** The function to run when this component is created and injected into the DOM. */\n    created: Function,\n\n    /** The function to run when this component is about to update its data. */\n    willUpdate: Function,\n\n    /** The function to run after this component has been updated. */\n    updated: Function,\n\n    /** The function that runs just before this component gets removed from the DOM. */\n    willDestroy: Function\n};\n\n\n/** Creates a new Mosaic component with configuration options.\n* @param {MosaicOptions} options The configuration options for this Mosaic. */\nconst Mosaic = function(options) {\n    let invalids = findInvalidOptions(options);\n    if(invalids !== undefined) throw new Error(invalids);\n\n    this.element = options.element;\n    this.router = options.router;\n    this.view = options.view;\n    this.created = options.created;\n    this.willUpdate = options.willUpdate;\n    this.updated = options.updated;\n    this.willDestroy = options.willDestroy;\n\n    // Make each array a proxy of its own so that \n    let _tempData = options.data;\n    for(var i in _tempData) {\n        if(!Array.isArray(_tempData[i])) continue;\n        \n        _tempData[i] = new Observable(_tempData[i], () => {}, () => {\n            let htree = viewToDOM(this.view, this);\n            patch(this.element, htree, this.element.parentNode, this);\n            if(this.updated) this.updated();\n        });\n    }\n    // Setup the data observer.\n    this.data = new Observable(_tempData || {}, (oldData) => {\n        if(this.willUpdate) this.willUpdate(oldData);\n    }, () => {\n        let htree = viewToDOM(this.view, this);\n        patch(this.element, htree, this.element.parentNode, this);\n        if(this.updated) this.updated();\n    });\n\n    // Check for a parent-child link.\n    if(options.link) {\n        this.parent = options.link.parent;\n        options.link.parent[options.link.name] = this;\n    }\n    this.actions = options.actions;\n    this.__isMosaic = true;\n\n    \n    \n    /** Destroys this instance of the Mosaic and triggers the willDestory lifecycle function. */\n    /* this feature is not working yet */\n    // this.destroy = function() {\n    //     const instance = this.element.__mosaicInstance;\n    //     const parent = instance.parent;\n        \n    //     // Remove the parent-child link.\n    //     if(parent) {\n    //         let keys = Object.keys(parent);\n    //         for(var i in keys) {\n    //             let val = parent[keys[i]];\n    //             if(val && val === this) {\n    //                 parent[keys[i]] = undefined;\n    //                 break;\n    //             }\n    //         };\n    //     }\n\n    //     if(instance && instance.willDestroy) instance.willDestroy();\n    //     this.element.remove();\n    // }\n\n    return this;\n}\n\n/** \"Paints\" the Mosaic onto the page by injecting it into its base element. */\nMosaic.prototype.paint = function() {\n    if(!this.element || !isHTMLElement(this.element)) {\n        throw new Error(`This Mosaic could not be painted because its element property is either not set\n        or is not a valid HTML element.`);\n    }\n    \n    // Clear anything that is there.\n    while(this.element.firstChild) this.element.removeChild(this.element.firstChild);\n\n    // Render an h-tree.\n    let htree = createElement(this);\n    render(htree, this.element, this);\n}\n\n\n/** A basic routing solution for Mosaic apps.\n* @param {Array} routes A list of routes of the form { path: String | Array of Strings, mosaic: Mosaic }. */\nMosaic.Router = Router;\n\n\n\n\n/** Static function for building a new instance of a Mosaic. Basically just takes a given VNode of a Mosaic\n * and uses it as a blueprint for how to build reusable instances of that component.\n */\nMosaic.view = function(vnode, $parent = null) {\n    let props = Object.assign({}, vnode.props);\n    \n    // Link is an optional relationship that can be added to each component.\n    let link = props.link || null;\n    \n    const _data = Object.assign({}, vnode.type.data, props);\n    if('link' in _data) delete _data['link'];\n    if('key' in _data) delete _data['key'];\n    if('style' in _data) delete _data['style'];\n    if('class' in _data) delete _data['class'];\n    if('id' in _data) delete _data['id'];\n    if('className' in _data) delete _data['className'];\n    if('checked' in _data) delete _data['checked'];\n    if('value' in _data) delete _data['value'];\n    \n    // Render a new instance of this component.\n    if(typeof vnode.type === 'object' && vnode.type.__isMosaic) {\n        const options = {\n            element: vnode.type.element,\n            router: vnode.type.router,\n            data: _data,\n            view: vnode.type.view,\n            actions: Object.assign({}, vnode.type.actions),\n            created: vnode.type.created,\n            willUpdate: vnode.type.willUpdate,\n            updated: vnode.type.updated,\n            willDestroy: vnode.type.willDestroy,\n            link: link\n        }\n        const instance = new Mosaic(options);\n        if(vnode.children && vnode.children.length > 0) instance.children = vnode.children;\n\n        // Bind actions after creation.\n        for(var i in instance.actions) instance.actions[i] = instance.actions[i].bind(instance);\n        \n        // Render the DOM element.\n        let htree = viewToDOM(instance.view, instance);\n        instance.element = render(htree, $parent, instance);\n        instance.element.__mosaicInstance = instance;\n        instance.element.__mosaicKey = vnode.props.key;\n\n        if(instance.created) instance.created();\n        return instance.element;\n    } else {\n        let htree = viewToDOM(vnode.type.view, vnode);\n        return render(htree, $parent);\n    }\n}\n\n/** Static function for diffing and patching changes between instances of Mosaics. */\nMosaic.patch = function($dom, vnode, $parent = $dom.parentNode) {\n    const props = Object.assign({}, vnode.props, { children: vnode.children });\n    \n    if($dom.__mosaicInstance && $dom.__mosaicInstance.constructor === vnode.type) {\n        $dom.__mosaicInstance.props = props;\n        let htree = viewToDOM($dom.__mosaicInstance.view, $dom.__mosaicInstance);\n        return patch($dom, htree, $parent, $dom.__mosaicInstance);\n    }\n    else if(typeof vnode.type === 'object' && vnode.type.__isMosaic === true) {\n        const $ndom = Mosaic.view(vnode, $parent);\n        return $parent ? ($parent.replaceChild($ndom, $dom) && $ndom) : $ndom;\n    }\n    else if(typeof vnode.type !== 'object' || vnode.type.__isMosaic === false) {\n        let htree = viewToDOM(vnode.type.view.bind(props), vnode.type);\n        return patch($dom, htree, $parent, $dom.__mosaicInstance);\n    }\n}\n\nwindow.h = createElement;\nwindow.Mosaic = Mosaic;\nexports.h = createElement;\nexports.Mosaic = Mosaic;"]}