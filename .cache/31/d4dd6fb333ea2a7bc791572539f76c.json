{"id":"../../../../../node_modules/firebase/messaging/controllers/controller-interface.js","dependencies":[{"name":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/controller-interface.js.map","includedInParent":true,"mtime":1494998757000},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/package.json","includedInParent":true,"mtime":1549253646323},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/.babelrc","includedInParent":true,"mtime":1549225258658},{"name":"/Users/adeolauthman/node_modules/firebase/package.json","includedInParent":true,"mtime":1495915167000},{"name":"../../app/errors","loc":{"line":28,"column":22},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/controller-interface.js","resolved":"/Users/adeolauthman/node_modules/firebase/app/errors.js"},{"name":"../models/errors","loc":{"line":30,"column":23},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/controller-interface.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/models/errors.js"},{"name":"../models/token-manager","loc":{"line":34,"column":28},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/controller-interface.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/models/token-manager.js"},{"name":"../models/notification-permission","loc":{"line":38,"column":38},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/controller-interface.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/models/notification-permission.js"}],"generated":{"js":"/*! @license Firebase v4.0.0\nBuild: rev-c054dab\nTerms: https://firebase.google.com/terms/ */\n\n/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _errors = require('../../app/errors');\n\nvar _errors2 = require('../models/errors');\n\nvar _errors3 = _interopRequireDefault(_errors2);\n\nvar _tokenManager = require('../models/token-manager');\n\nvar _tokenManager2 = _interopRequireDefault(_tokenManager);\n\nvar _notificationPermission = require('../models/notification-permission');\n\nvar _notificationPermission2 = _interopRequireDefault(_notificationPermission);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nvar ControllerInterface = function () {\n    /**\n     * An interface of the Messaging Service API\n     * @param {!firebase.app.App} app\n     */\n    function ControllerInterface(app) {\n        var _this = this;\n\n        _classCallCheck(this, ControllerInterface);\n\n        this.errorFactory_ = new _errors.ErrorFactory('messaging', 'Messaging', _errors3.default.map);\n        if (!app.options[SENDER_ID_OPTION_NAME] || typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n            throw this.errorFactory_.create(_errors3.default.codes.BAD_SENDER_ID);\n        }\n        this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n        this.tokenManager_ = new _tokenManager2.default();\n        this.app = app;\n        this.INTERNAL = {};\n        this.INTERNAL.delete = function () {\n            return _this.delete;\n        };\n    }\n    /**\n     * @export\n     * @return {Promise<string> | Promise<null>} Returns a promise that\n     * resolves to an FCM token.\n     */\n\n\n    _createClass(ControllerInterface, [{\n        key: 'getToken',\n        value: function getToken() {\n            var _this2 = this;\n\n            // Check with permissions\n            var currentPermission = this.getNotificationPermission_();\n            if (currentPermission !== _notificationPermission2.default.granted) {\n                if (currentPermission === _notificationPermission2.default.denied) {\n                    return Promise.reject(this.errorFactory_.create(_errors3.default.codes.NOTIFICATIONS_BLOCKED));\n                }\n                // We must wait for permission to be granted\n                return Promise.resolve(null);\n            }\n            return this.getSWRegistration_().then(function (registration) {\n                return _this2.tokenManager_.getSavedToken(_this2.messagingSenderId_, registration).then(function (token) {\n                    if (token) {\n                        return token;\n                    }\n                    return _this2.tokenManager_.createToken(_this2.messagingSenderId_, registration);\n                });\n            });\n        }\n        /**\n         * This method deletes tokens that the token manager looks after and then\n         * unregisters the push subscription if it exists.\n         * @export\n         * @param {string} token\n         * @return {Promise<void>}\n         */\n\n    }, {\n        key: 'deleteToken',\n        value: function deleteToken(token) {\n            var _this3 = this;\n\n            return this.tokenManager_.deleteToken(token).then(function () {\n                return _this3.getSWRegistration_().then(function (registration) {\n                    if (registration) {\n                        return registration.pushManager.getSubscription();\n                    }\n                }).then(function (subscription) {\n                    if (subscription) {\n                        return subscription.unsubscribe();\n                    }\n                });\n            });\n        }\n    }, {\n        key: 'getSWRegistration_',\n        value: function getSWRegistration_() {\n            throw this.errorFactory_.create(_errors3.default.codes.SHOULD_BE_INHERITED);\n        }\n        //\n        // The following methods should only be available in the window.\n        //\n\n    }, {\n        key: 'requestPermission',\n        value: function requestPermission() {\n            throw this.errorFactory_.create(_errors3.default.codes.AVAILABLE_IN_WINDOW);\n        }\n        /**\n         * @export\n         * @param {!ServiceWorkerRegistration} registration\n         */\n\n    }, {\n        key: 'useServiceWorker',\n        value: function useServiceWorker() {\n            throw this.errorFactory_.create(_errors3.default.codes.AVAILABLE_IN_WINDOW);\n        }\n        /**\n         * @export\n         * @param {!firebase.Observer|function(*)} nextOrObserver\n         * @param {function(!Error)=} optError\n         * @param {function()=} optCompleted\n         * @return {!function()}\n         */\n\n    }, {\n        key: 'onMessage',\n        value: function onMessage() {\n            throw this.errorFactory_.create(_errors3.default.codes.AVAILABLE_IN_WINDOW);\n        }\n        /**\n         * @export\n         * @param {!firebase.Observer|function()} nextOrObserver An observer object\n         * or a function triggered on token refresh.\n         * @param {function(!Error)=} optError Optional A function\n         * triggered on token refresh error.\n         * @param {function()=} optCompleted Optional function triggered when the\n         * observer is removed.\n         * @return {!function()} The unsubscribe function for the observer.\n         */\n\n    }, {\n        key: 'onTokenRefresh',\n        value: function onTokenRefresh() {\n            throw this.errorFactory_.create(_errors3.default.codes.AVAILABLE_IN_WINDOW);\n        }\n        //\n        // The following methods are used by the service worker only.\n        //\n        /**\n         * @export\n         * @param {function(Object)} callback\n         */\n\n    }, {\n        key: 'setBackgroundMessageHandler',\n        value: function setBackgroundMessageHandler() {\n            throw this.errorFactory_.create(_errors3.default.codes.AVAILABLE_IN_SW);\n        }\n        //\n        // The following methods are used by the service themselves and not exposed\n        // publicly or not expected to be used by developers.\n        //\n        /**\n         * This method is required to adhere to the Firebase interface.\n         * It closes any currently open indexdb database connections.\n         */\n\n    }, {\n        key: 'delete',\n        value: function _delete() {\n            this.tokenManager_.closeDatabase();\n        }\n        /**\n         * Returns the current Notification Permission state.\n         * @private\n         * @return {string} The currenct permission state.\n         */\n\n    }, {\n        key: 'getNotificationPermission_',\n        value: function getNotificationPermission_() {\n            return Notification.permission;\n        }\n        /**\n         * @protected\n         * @returns {TokenManager}\n         */\n\n    }, {\n        key: 'getTokenManager',\n        value: function getTokenManager() {\n            return this.tokenManager_;\n        }\n    }]);\n\n    return ControllerInterface;\n}();\n\nexports.default = ControllerInterface;\nmodule.exports = exports['default'];\n\n","map":{"version":3,"sources":["src/messaging/controllers/controller-interface.ts"],"names":["SENDER_ID_OPTION_NAME","ControllerInterface","app","errorFactory_","map","options","create","codes","BAD_SENDER_ID","messagingSenderId_","tokenManager_","INTERNAL","delete","currentPermission","getNotificationPermission_","granted","denied","Promise","reject","NOTIFICATIONS_BLOCKED","resolve","getSWRegistration_","then","getSavedToken","registration","token","createToken","deleteToken","pushManager","getSubscription","subscription","unsubscribe","SHOULD_BE_INHERITED","AVAILABLE_IN_WINDOW","AVAILABLE_IN_SW","closeDatabase","Notification","permission"],"mappings":"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","file":"controller-interface.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport {ErrorFactory} from '../../app/errors';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\n\nconst SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nexport default class ControllerInterface {\n\n  public app;\n  public INTERNAL;\n  protected errorFactory_;\n  private messagingSenderId_: string;\n  private tokenManager_: TokenManager;\n\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (!app.options[SENDER_ID_OPTION_NAME] ||\n        typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n\n    this.tokenManager_ = new TokenManager();\n\n    this.app = app;\n    this.INTERNAL = {};\n    this.INTERNAL.delete = () => this.delete;\n  }\n\n  /**\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise that\n   * resolves to an FCM token.\n   */\n  getToken() {\n    // Check with permissions\n    const currentPermission = this.getNotificationPermission_();\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(\n            this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED)\n        );\n      }\n\n      // We must wait for permission to be granted\n      return Promise.resolve(null);\n    }\n\n    return this.getSWRegistration_()\n      .then(registration => {\n        return this.tokenManager_.getSavedToken(\n            this.messagingSenderId_, registration)\n              .then(token => {\n                if (token) {\n                  return token;\n                }\n\n                return this.tokenManager_.createToken(this.messagingSenderId_,\n                  registration);\n              });\n      });\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after and then\n   * unregisters the push subscription if it exists.\n   * @export\n   * @param {string} token\n   * @return {Promise<void>}\n   */\n  deleteToken(token) {\n    return this.tokenManager_.deleteToken(token)\n      .then(() => {\n        return this.getSWRegistration_()\n        .then((registration) => {\n          if (registration) {\n            return registration.pushManager.getSubscription();\n          }\n        })\n        .then(subscription => {\n          if (subscription) {\n            return subscription.unsubscribe();\n          }\n        });\n      });\n  }\n\n  getSWRegistration_(): Promise<ServiceWorkerRegistration>  {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  requestPermission() {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n  useServiceWorker(registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n  setBackgroundMessageHandler(callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  delete() {\n    this.tokenManager_.closeDatabase();\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n  getNotificationPermission_() {\n    return (Notification as any).permission;\n  }\n\n  /**\n   * @protected\n   * @returns {TokenManager}\n   */\n  getTokenManager() {\n    return this.tokenManager_;\n  }\n}\n"]}},"hash":"aaeef0035f494b99941f60ad75becbf3","cacheData":{"env":{}}}