{"id":"../../../../../node_modules/firebase/storage/task.js","dependencies":[{"name":"/Users/adeolauthman/node_modules/firebase/storage/task.js.map","includedInParent":true,"mtime":1494998756000},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/package.json","includedInParent":true,"mtime":1549253646323},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/.babelrc","includedInParent":true,"mtime":1549225258658},{"name":"/Users/adeolauthman/node_modules/firebase/package.json","includedInParent":true,"mtime":1495915167000},{"name":"./implementation/taskenums","loc":{"line":32,"column":25},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/taskenums.js"},{"name":"./implementation/observer","loc":{"line":36,"column":24},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/observer.js"},{"name":"./tasksnapshot","loc":{"line":38,"column":28},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/tasksnapshot.js"},{"name":"./implementation/args","loc":{"line":40,"column":20},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/args.js"},{"name":"./implementation/array","loc":{"line":44,"column":21},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/array.js"},{"name":"./implementation/async","loc":{"line":48,"column":21},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/async.js"},{"name":"./implementation/error","loc":{"line":50,"column":21},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/error.js"},{"name":"./implementation/promise_external","loc":{"line":54,"column":32},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/promise_external.js"},{"name":"./implementation/requests","loc":{"line":58,"column":24},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/requests.js"},{"name":"./implementation/type","loc":{"line":62,"column":20},"parent":"/Users/adeolauthman/node_modules/firebase/storage/task.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/type.js"}],"generated":{"js":"/*! @license Firebase v4.0.0\nBuild: rev-c054dab\nTerms: https://firebase.google.com/terms/ */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.UploadTask = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Copyright 2017 Google Inc.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * you may not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *   http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Unless required by applicable law or agreed to in writing, software\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * See the License for the specific language governing permissions and\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * limitations under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\n\nvar _taskenums = require('./implementation/taskenums');\n\nvar fbsTaskEnums = _interopRequireWildcard(_taskenums);\n\nvar _observer = require('./implementation/observer');\n\nvar _tasksnapshot = require('./tasksnapshot');\n\nvar _args = require('./implementation/args');\n\nvar fbsArgs = _interopRequireWildcard(_args);\n\nvar _array = require('./implementation/array');\n\nvar fbsArray = _interopRequireWildcard(_array);\n\nvar _async = require('./implementation/async');\n\nvar _error = require('./implementation/error');\n\nvar errors = _interopRequireWildcard(_error);\n\nvar _promise_external = require('./implementation/promise_external');\n\nvar fbsPromiseimpl = _interopRequireWildcard(_promise_external);\n\nvar _requests = require('./implementation/requests');\n\nvar fbsRequests = _interopRequireWildcard(_requests);\n\nvar _type = require('./implementation/type');\n\nvar typeUtils = _interopRequireWildcard(_type);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nvar UploadTask = exports.UploadTask = function () {\n    /**\n     * @param ref The firebaseStorage.Reference object this task came\n     *     from, untyped to avoid cyclic dependencies.\n     * @param blob The blob to upload.\n     */\n    function UploadTask(ref, authWrapper, location, mappings, blob) {\n        var _this = this;\n\n        var metadata = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n        _classCallCheck(this, UploadTask);\n\n        this.transferred_ = 0;\n        this.needToFetchStatus_ = false;\n        this.needToFetchMetadata_ = false;\n        this.observers_ = [];\n        this.error_ = null;\n        this.uploadUrl_ = null;\n        this.request_ = null;\n        this.chunkMultiplier_ = 1;\n        this.resolve_ = null;\n        this.reject_ = null;\n        this.ref_ = ref;\n        this.authWrapper_ = authWrapper;\n        this.location_ = location;\n        this.blob_ = blob;\n        this.metadata_ = metadata;\n        this.mappings_ = mappings;\n        this.resumable_ = this.shouldDoResumable_(this.blob_);\n        this.state_ = _taskenums.InternalTaskState.RUNNING;\n        this.errorHandler_ = function (error) {\n            _this.request_ = null;\n            _this.chunkMultiplier_ = 1;\n            if (error.codeEquals(errors.Code.CANCELED)) {\n                _this.needToFetchStatus_ = true;\n                _this.completeTransitions_();\n            } else {\n                _this.error_ = error;\n                _this.transition_(_taskenums.InternalTaskState.ERROR);\n            }\n        };\n        this.metadataErrorHandler_ = function (error) {\n            _this.request_ = null;\n            if (error.codeEquals(errors.Code.CANCELED)) {\n                _this.completeTransitions_();\n            } else {\n                _this.error_ = error;\n                _this.transition_(_taskenums.InternalTaskState.ERROR);\n            }\n        };\n        this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n            _this.start_();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this.promise_.then(null, function () {});\n    }\n\n    _createClass(UploadTask, [{\n        key: 'makeProgressCallback_',\n        value: function makeProgressCallback_() {\n            var _this2 = this;\n\n            var sizeBefore = this.transferred_;\n            return function (loaded) {\n                _this2.updateProgress_(sizeBefore + loaded);\n            };\n        }\n    }, {\n        key: 'shouldDoResumable_',\n        value: function shouldDoResumable_(blob) {\n            return blob.size() > 256 * 1024;\n        }\n    }, {\n        key: 'start_',\n        value: function start_() {\n            if (this.state_ !== _taskenums.InternalTaskState.RUNNING) {\n                // This can happen if someone pauses us in a resume callback, for example.\n                return;\n            }\n            if (this.request_ !== null) {\n                return;\n            }\n            if (this.resumable_) {\n                if (this.uploadUrl_ === null) {\n                    this.createResumable_();\n                } else {\n                    if (this.needToFetchStatus_) {\n                        this.fetchStatus_();\n                    } else {\n                        if (this.needToFetchMetadata_) {\n                            // Happens if we miss the metadata on upload completion.\n                            this.fetchMetadata_();\n                        } else {\n                            this.continueUpload_();\n                        }\n                    }\n                }\n            } else {\n                this.oneShotUpload_();\n            }\n        }\n    }, {\n        key: 'resolveToken_',\n        value: function resolveToken_(callback) {\n            var _this3 = this;\n\n            this.authWrapper_.getAuthToken().then(function (authToken) {\n                switch (_this3.state_) {\n                    case _taskenums.InternalTaskState.RUNNING:\n                        callback(authToken);\n                        break;\n                    case _taskenums.InternalTaskState.CANCELING:\n                        _this3.transition_(_taskenums.InternalTaskState.CANCELED);\n                        break;\n                    case _taskenums.InternalTaskState.PAUSING:\n                        _this3.transition_(_taskenums.InternalTaskState.PAUSED);\n                        break;\n                    default:\n                }\n            });\n        }\n        // TODO(andysoto): assert false\n\n    }, {\n        key: 'createResumable_',\n        value: function createResumable_() {\n            var _this4 = this;\n\n            this.resolveToken_(function (authToken) {\n                var requestInfo = fbsRequests.createResumableUpload(_this4.authWrapper_, _this4.location_, _this4.mappings_, _this4.blob_, _this4.metadata_);\n                var createRequest = _this4.authWrapper_.makeRequest(requestInfo, authToken);\n                _this4.request_ = createRequest;\n                createRequest.getPromise().then(function (url) {\n                    _this4.request_ = null;\n                    _this4.uploadUrl_ = url;\n                    _this4.needToFetchStatus_ = false;\n                    _this4.completeTransitions_();\n                }, _this4.errorHandler_);\n            });\n        }\n    }, {\n        key: 'fetchStatus_',\n        value: function fetchStatus_() {\n            var _this5 = this;\n\n            // TODO(andysoto): assert(this.uploadUrl_ !== null);\n            var url = this.uploadUrl_;\n            this.resolveToken_(function (authToken) {\n                var requestInfo = fbsRequests.getResumableUploadStatus(_this5.authWrapper_, _this5.location_, url, _this5.blob_);\n                var statusRequest = _this5.authWrapper_.makeRequest(requestInfo, authToken);\n                _this5.request_ = statusRequest;\n                statusRequest.getPromise().then(function (status) {\n                    status = status;\n                    _this5.request_ = null;\n                    _this5.updateProgress_(status.current);\n                    _this5.needToFetchStatus_ = false;\n                    if (status.finalized) {\n                        _this5.needToFetchMetadata_ = true;\n                    }\n                    _this5.completeTransitions_();\n                }, _this5.errorHandler_);\n            });\n        }\n    }, {\n        key: 'continueUpload_',\n        value: function continueUpload_() {\n            var _this6 = this;\n\n            var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n            var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size());\n            // TODO(andysoto): assert(this.uploadUrl_ !== null);\n            var url = this.uploadUrl_;\n            this.resolveToken_(function (authToken) {\n                var requestInfo = void 0;\n                try {\n                    requestInfo = fbsRequests.continueResumableUpload(_this6.location_, _this6.authWrapper_, url, _this6.blob_, chunkSize, _this6.mappings_, status, _this6.makeProgressCallback_());\n                } catch (e) {\n                    _this6.error_ = e;\n                    _this6.transition_(_taskenums.InternalTaskState.ERROR);\n                    return;\n                }\n                var uploadRequest = _this6.authWrapper_.makeRequest(requestInfo, authToken);\n                _this6.request_ = uploadRequest;\n                uploadRequest.getPromise().then(function (newStatus) {\n                    _this6.increaseMultiplier_();\n                    _this6.request_ = null;\n                    _this6.updateProgress_(newStatus.current);\n                    if (newStatus.finalized) {\n                        _this6.metadata_ = newStatus.metadata;\n                        _this6.transition_(_taskenums.InternalTaskState.SUCCESS);\n                    } else {\n                        _this6.completeTransitions_();\n                    }\n                }, _this6.errorHandler_);\n            });\n        }\n    }, {\n        key: 'increaseMultiplier_',\n        value: function increaseMultiplier_() {\n            var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n            // Max chunk size is 32M.\n            if (currentSize < 32 * 1024 * 1024) {\n                this.chunkMultiplier_ *= 2;\n            }\n        }\n    }, {\n        key: 'fetchMetadata_',\n        value: function fetchMetadata_() {\n            var _this7 = this;\n\n            this.resolveToken_(function (authToken) {\n                var requestInfo = fbsRequests.getMetadata(_this7.authWrapper_, _this7.location_, _this7.mappings_);\n                var metadataRequest = _this7.authWrapper_.makeRequest(requestInfo, authToken);\n                _this7.request_ = metadataRequest;\n                metadataRequest.getPromise().then(function (metadata) {\n                    _this7.request_ = null;\n                    _this7.metadata_ = metadata;\n                    _this7.transition_(_taskenums.InternalTaskState.SUCCESS);\n                }, _this7.metadataErrorHandler_);\n            });\n        }\n    }, {\n        key: 'oneShotUpload_',\n        value: function oneShotUpload_() {\n            var _this8 = this;\n\n            this.resolveToken_(function (authToken) {\n                var requestInfo = fbsRequests.multipartUpload(_this8.authWrapper_, _this8.location_, _this8.mappings_, _this8.blob_, _this8.metadata_);\n                var multipartRequest = _this8.authWrapper_.makeRequest(requestInfo, authToken);\n                _this8.request_ = multipartRequest;\n                multipartRequest.getPromise().then(function (metadata) {\n                    _this8.request_ = null;\n                    _this8.metadata_ = metadata;\n                    _this8.updateProgress_(_this8.blob_.size());\n                    _this8.transition_(_taskenums.InternalTaskState.SUCCESS);\n                }, _this8.errorHandler_);\n            });\n        }\n    }, {\n        key: 'updateProgress_',\n        value: function updateProgress_(transferred) {\n            var old = this.transferred_;\n            this.transferred_ = transferred;\n            // A progress update can make the \"transferred\" value smaller (e.g. a\n            // partial upload not completed by server, after which the \"transferred\"\n            // value may reset to the value at the beginning of the request).\n            if (this.transferred_ !== old) {\n                this.notifyObservers_();\n            }\n        }\n    }, {\n        key: 'transition_',\n        value: function transition_(state) {\n            if (this.state_ === state) {\n                return;\n            }\n            switch (state) {\n                case _taskenums.InternalTaskState.CANCELING:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.RUNNING ||\n                    //        this.state_ === InternalTaskState.PAUSING);\n                    this.state_ = state;\n                    if (this.request_ !== null) {\n                        this.request_.cancel();\n                    }\n                    break;\n                case _taskenums.InternalTaskState.PAUSING:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.RUNNING);\n                    this.state_ = state;\n                    if (this.request_ !== null) {\n                        this.request_.cancel();\n                    }\n                    break;\n                case _taskenums.InternalTaskState.RUNNING:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.PAUSED ||\n                    //        this.state_ === InternalTaskState.PAUSING);\n                    var wasPaused = this.state_ === _taskenums.InternalTaskState.PAUSED;\n                    this.state_ = state;\n                    if (wasPaused) {\n                        this.notifyObservers_();\n                        this.start_();\n                    }\n                    break;\n                case _taskenums.InternalTaskState.PAUSED:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.PAUSING);\n                    this.state_ = state;\n                    this.notifyObservers_();\n                    break;\n                case _taskenums.InternalTaskState.CANCELED:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.PAUSED ||\n                    //        this.state_ === InternalTaskState.CANCELING);\n                    this.error_ = errors.canceled();\n                    this.state_ = state;\n                    this.notifyObservers_();\n                    break;\n                case _taskenums.InternalTaskState.ERROR:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.RUNNING ||\n                    //        this.state_ === InternalTaskState.PAUSING ||\n                    //        this.state_ === InternalTaskState.CANCELING);\n                    this.state_ = state;\n                    this.notifyObservers_();\n                    break;\n                case _taskenums.InternalTaskState.SUCCESS:\n                    // TODO(andysoto):\n                    // assert(this.state_ === InternalTaskState.RUNNING ||\n                    //        this.state_ === InternalTaskState.PAUSING ||\n                    //        this.state_ === InternalTaskState.CANCELING);\n                    this.state_ = state;\n                    this.notifyObservers_();\n                    break;\n            }\n        }\n    }, {\n        key: 'completeTransitions_',\n        value: function completeTransitions_() {\n            switch (this.state_) {\n                case _taskenums.InternalTaskState.PAUSING:\n                    this.transition_(_taskenums.InternalTaskState.PAUSED);\n                    break;\n                case _taskenums.InternalTaskState.CANCELING:\n                    this.transition_(_taskenums.InternalTaskState.CANCELED);\n                    break;\n                case _taskenums.InternalTaskState.RUNNING:\n                    this.start_();\n                    break;\n                default:\n                    // TODO(andysoto): assert(false);\n                    break;\n            }\n        }\n    }, {\n        key: 'on',\n\n        /**\n         * Adds a callback for an event.\n         * @param type The type of event to listen for.\n         */\n        value: function on(type) {\n            var nextOrObserver = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n            var error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n            var completed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n            var nextOrObserverMessage = 'Expected a function or an Object with one of ' + '`next`, `error`, `complete` properties.';\n            var nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n            var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n            function nextOrObserverValidator(p) {\n                try {\n                    nextValidator(p);\n                    return;\n                } catch (e) {}\n                try {\n                    observerValidator(p);\n                    var anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) || typeUtils.isJustDef(p['complete']);\n                    if (!anyDefined) {\n                        throw '';\n                    }\n                } catch (e) {\n                    throw nextOrObserverMessage;\n                }\n            }\n            var specs = [fbsArgs.stringSpec(function () {\n                if (type !== _taskenums.TaskEvent.STATE_CHANGED) {\n                    throw 'Expected one of the event types: [' + _taskenums.TaskEvent.STATE_CHANGED + '].';\n                }\n            }), fbsArgs.looseObjectSpec(nextOrObserverValidator, true), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n            fbsArgs.validate('on', specs, arguments);\n            var self = this;\n            function makeBinder(specs) {\n                return function (nextOrObserver, error) {\n                    if (specs !== null) {\n                        fbsArgs.validate('on', specs, arguments);\n                    }\n                    var observer = new _observer.Observer(nextOrObserver, error, completed);\n                    self.addObserver_(observer);\n                    return function () {\n                        self.removeObserver_(observer);\n                    };\n                };\n            }\n\n            var binderSpecs = [fbsArgs.looseObjectSpec(function (p) {\n                if (p === null) {\n                    throw nextOrObserverMessage;\n                }\n                nextOrObserverValidator(p);\n            }), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n            var typeOnly = !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) || typeUtils.isJustDef(completed));\n            if (typeOnly) {\n                return makeBinder(binderSpecs);\n            } else {\n                return makeBinder(null)(nextOrObserver, error, completed);\n            }\n        }\n        /**\n         * This object behaves like a Promise, and resolves with its snapshot data\n         * when the upload completes.\n         *     The fulfillment callback. Promise chaining works as normal.\n         * @param onRejected The rejection callback.\n         */\n\n    }, {\n        key: 'then',\n        value: function then(onFulfilled, onRejected) {\n            return this.promise_.then(onFulfilled, onRejected);\n        }\n        /**\n         * Equivalent to calling `then(null, onRejected)`.\n         */\n\n    }, {\n        key: 'catch',\n        value: function _catch(onRejected) {\n            return this.then(null, onRejected);\n        }\n        /**\n         * Adds the given observer.\n         */\n\n    }, {\n        key: 'addObserver_',\n        value: function addObserver_(observer) {\n            this.observers_.push(observer);\n            this.notifyObserver_(observer);\n        }\n        /**\n         * Removes the given observer.\n         */\n\n    }, {\n        key: 'removeObserver_',\n        value: function removeObserver_(observer) {\n            fbsArray.remove(this.observers_, observer);\n        }\n    }, {\n        key: 'notifyObservers_',\n        value: function notifyObservers_() {\n            var _this9 = this;\n\n            this.finishPromise_();\n            var observers = fbsArray.clone(this.observers_);\n            observers.forEach(function (observer) {\n                _this9.notifyObserver_(observer);\n            });\n        }\n    }, {\n        key: 'finishPromise_',\n        value: function finishPromise_() {\n            if (this.resolve_ !== null) {\n                var triggered = true;\n                switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n                    case _taskenums.TaskState.SUCCESS:\n                        (0, _async.async)(this.resolve_.bind(null, this.snapshot))();\n                        break;\n                    case _taskenums.TaskState.CANCELED:\n                    case _taskenums.TaskState.ERROR:\n                        var toCall = this.reject_;\n                        (0, _async.async)(toCall.bind(null, this.error_))();\n                        break;\n                    default:\n                        triggered = false;\n                        break;\n                }\n                if (triggered) {\n                    this.resolve_ = null;\n                    this.reject_ = null;\n                }\n            }\n        }\n    }, {\n        key: 'notifyObserver_',\n        value: function notifyObserver_(observer) {\n            var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n            switch (externalState) {\n                case _taskenums.TaskState.RUNNING:\n                case _taskenums.TaskState.PAUSED:\n                    if (observer.next !== null) {\n                        (0, _async.async)(observer.next.bind(observer, this.snapshot))();\n                    }\n                    break;\n                case _taskenums.TaskState.SUCCESS:\n                    if (observer.complete !== null) {\n                        (0, _async.async)(observer.complete.bind(observer))();\n                    }\n                    break;\n                case _taskenums.TaskState.CANCELED:\n                case _taskenums.TaskState.ERROR:\n                    if (observer.error !== null) {\n                        (0, _async.async)(observer.error.bind(observer, this.error_))();\n                    }\n                    break;\n                default:\n                    // TODO(andysoto): assert(false);\n                    if (observer.error !== null) {\n                        (0, _async.async)(observer.error.bind(observer, this.error_))();\n                    }\n            }\n        }\n        /**\n         * Resumes a paused task. Has no effect on a currently running or failed task.\n         * @return True if the operation took effect, false if ignored.\n         */\n\n    }, {\n        key: 'resume',\n        value: function resume() {\n            fbsArgs.validate('resume', [], arguments);\n            var valid = this.state_ === _taskenums.InternalTaskState.PAUSED || this.state_ === _taskenums.InternalTaskState.PAUSING;\n            if (valid) {\n                this.transition_(_taskenums.InternalTaskState.RUNNING);\n            }\n            return valid;\n        }\n        /**\n         * Pauses a currently running task. Has no effect on a paused or failed task.\n         * @return True if the operation took effect, false if ignored.\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            fbsArgs.validate('pause', [], arguments);\n            var valid = this.state_ === _taskenums.InternalTaskState.RUNNING;\n            if (valid) {\n                this.transition_(_taskenums.InternalTaskState.PAUSING);\n            }\n            return valid;\n        }\n        /**\n         * Cancels a currently running or paused task. Has no effect on a complete or\n         * failed task.\n         * @return True if the operation took effect, false if ignored.\n         */\n\n    }, {\n        key: 'cancel',\n        value: function cancel() {\n            fbsArgs.validate('cancel', [], arguments);\n            var valid = this.state_ === _taskenums.InternalTaskState.RUNNING || this.state_ === _taskenums.InternalTaskState.PAUSING;\n            if (valid) {\n                this.transition_(_taskenums.InternalTaskState.CANCELING);\n            }\n            return valid;\n        }\n    }, {\n        key: 'snapshot',\n        get: function get() {\n            var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n            return new _tasksnapshot.UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);\n        }\n    }]);\n\n    return UploadTask;\n}();\n\n","map":{"version":3,"sources":["../src/storage/task.ts"],"names":["fbsTaskEnums","fbsArgs","fbsArray","errors","fbsPromiseimpl","fbsRequests","typeUtils","UploadTask","ref","authWrapper","location","mappings","blob","metadata","transferred_","needToFetchStatus_","needToFetchMetadata_","observers_","error_","uploadUrl_","request_","chunkMultiplier_","resolve_","reject_","ref_","authWrapper_","location_","blob_","metadata_","mappings_","resumable_","shouldDoResumable_","state_","RUNNING","errorHandler_","error","codeEquals","Code","CANCELED","completeTransitions_","transition_","ERROR","metadataErrorHandler_","promise_","make","resolve","reject","start_","then","sizeBefore","loaded","updateProgress_","size","createResumable_","fetchStatus_","fetchMetadata_","continueUpload_","oneShotUpload_","callback","getAuthToken","authToken","CANCELING","PAUSING","PAUSED","resolveToken_","requestInfo","createResumableUpload","createRequest","makeRequest","getPromise","url","getResumableUploadStatus","statusRequest","status","current","finalized","chunkSize","resumableUploadChunkSize","ResumableUploadStatus","continueResumableUpload","makeProgressCallback_","e","uploadRequest","newStatus","increaseMultiplier_","SUCCESS","currentSize","getMetadata","metadataRequest","multipartUpload","multipartRequest","transferred","old","notifyObservers_","state","cancel","wasPaused","canceled","type","nextOrObserver","undefined","completed","nextOrObserverMessage","nextValidator","nullFunctionSpec","validator","observerValidator","looseObjectSpec","nextOrObserverValidator","p","anyDefined","isJustDef","specs","stringSpec","STATE_CHANGED","validate","arguments","self","makeBinder","observer","addObserver_","removeObserver_","binderSpecs","typeOnly","onFulfilled","onRejected","push","notifyObserver_","remove","finishPromise_","observers","clone","forEach","triggered","taskStateFromInternalTaskState","bind","snapshot","toCall","externalState","next","complete","valid"],"mappings":"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","file":"task.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\nimport {AuthWrapper} from './implementation/authwrapper';\nimport {FbsBlob} from './implementation/blob';\nimport {FirebaseStorageError} from './implementation/error';\nimport {InternalTaskState} from './implementation/taskenums';\nimport {Metadata} from './metadata';\nimport {NextFn, ErrorFn, CompleteFn, Unsubscribe, Observer} from './implementation/observer';\nimport {Request} from './implementation/request';\nimport * as RequestExports from './implementation/request';\nimport {Subscribe} from './implementation/observer';\nimport {TaskEvent, TaskState} from './implementation/taskenums';\nimport {UploadTaskSnapshot} from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport {ArgSpec} from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport {async as fbsAsync} from './implementation/async';\nimport {errors as fbsErrors} from './implementation/error';\nimport * as errors from './implementation/error';\nimport {Location} from './implementation/location';\nimport * as fbsMetadata from './implementation/metadata';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport {RequestInfo} from './implementation/requestinfo';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\nimport {Reference} from './reference';\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nexport class UploadTask {\n  private ref_: Reference;\n  private authWrapper_: AuthWrapper;\n  private location_: Location;\n  private blob_: FbsBlob;\n  private metadata_: Metadata|null;\n  private mappings_: fbsMetadata.Mappings;\n  private transferred_: number = 0;\n  private needToFetchStatus_: boolean = false;\n  private needToFetchMetadata_: boolean = false;\n  private observers_: Observer<UploadTaskSnapshot>[] = [];\n  private resumable_: boolean;\n  private state_: InternalTaskState;\n  private error_: Error|null = null;\n  private uploadUrl_: string|null = null;\n  private request_: Request<any>|null = null;\n  private chunkMultiplier_: number = 1;\n  private errorHandler_: (p1: FirebaseStorageError) => void;\n  private metadataErrorHandler_: (p1: FirebaseStorageError) => void;\n  private resolve_:\n      ((p1: UploadTaskSnapshot) => void) | null = null;\n  private reject_: ((p1: Error) => void) | null = null;\n  private promise_: Promise<UploadTaskSnapshot>;\n\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  constructor(\n      ref: Reference, authWrapper: AuthWrapper, location: Location,\n      mappings: fbsMetadata.Mappings, blob: FbsBlob, metadata: Metadata|null = null) {\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = (error) => {\n      this.request_ = null;\n      this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.needToFetchStatus_ = true;\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = (error) => {\n      this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make((resolve, reject) => {\n      this.resolve_ = resolve;\n      this.reject_ = reject;\n      this.start_();\n    });\n\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, () => {});\n  }\n\n  private makeProgressCallback_():\n      (p1: number, p2: number) => void {\n    const sizeBefore = this.transferred_;\n    return (loaded, total) => {\n      this.updateProgress_(sizeBefore + loaded);\n    };\n  }\n\n  private shouldDoResumable_(blob: FbsBlob): boolean {\n    return blob.size() > 256 * 1024;\n  }\n\n  private start_() {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  }\n\n  private resolveToken_(callback: (p1: string|null) => void) {\n    this.authWrapper_.getAuthToken().then((authToken) => {\n      switch (this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  }\n\n  // TODO(andysoto): assert false\n\n  private createResumable_() {\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.createResumableUpload(\n          this.authWrapper_, this.location_, this.mappings_, this.blob_,\n          this.metadata_);\n      const createRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = createRequest;\n      createRequest.getPromise().then(\n          (url: string) => {\n            this.request_ = null;\n            this.uploadUrl_ = url;\n            this.needToFetchStatus_ = false;\n            this.completeTransitions_();\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private fetchStatus_() {\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = (this.uploadUrl_ as string);\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.getResumableUploadStatus(\n          this.authWrapper_, this.location_, url, this.blob_);\n      const statusRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = statusRequest;\n      statusRequest.getPromise().then(\n          (status) => {\n            status = (status as fbsRequests.ResumableUploadStatus);\n            this.request_ = null;\n            this.updateProgress_(status.current);\n            this.needToFetchStatus_ = false;\n            if (status.finalized) {\n              this.needToFetchMetadata_ = true;\n            }\n            this.completeTransitions_();\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private continueUpload_() {\n    const chunkSize =\n        fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    const status = new fbsRequests.ResumableUploadStatus(\n        this.transferred_, this.blob_.size());\n\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = (this.uploadUrl_ as string);\n    this.resolveToken_((authToken) => {\n    let requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(\n            this.location_, this.authWrapper_, url, this.blob_, chunkSize,\n            this.mappings_, status, this.makeProgressCallback_());\n      } catch (e) {\n        this.error_ = e;\n        this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      const uploadRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = uploadRequest;\n      uploadRequest.getPromise().then(\n          (newStatus: fbsRequests.ResumableUploadStatus) => {\n            this.increaseMultiplier_();\n            this.request_ = null;\n            this.updateProgress_(newStatus.current);\n            if (newStatus.finalized) {\n              this.metadata_ = newStatus.metadata;\n              this.transition_(InternalTaskState.SUCCESS);\n            } else {\n              this.completeTransitions_();\n            }\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private increaseMultiplier_() {\n    const currentSize =\n        fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  }\n\n  private fetchMetadata_() {\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.getMetadata(\n          this.authWrapper_, this.location_, this.mappings_);\n      const metadataRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(\n          (metadata) => {\n            this.request_ = null;\n            this.metadata_ = metadata;\n            this.transition_(InternalTaskState.SUCCESS);\n          },\n          this.metadataErrorHandler_);\n    });\n  }\n\n  private oneShotUpload_() {\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.multipartUpload(\n          this.authWrapper_, this.location_, this.mappings_, this.blob_,\n          this.metadata_);\n      const multipartRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(\n          (metadata) => {\n            this.request_ = null;\n            this.metadata_ = metadata;\n            this.updateProgress_(this.blob_.size());\n            this.transition_(InternalTaskState.SUCCESS);\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private updateProgress_(transferred: number) {\n    const old = this.transferred_;\n    this.transferred_ = transferred;\n\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  }\n\n  private transition_(state: InternalTaskState) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        const wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  }\n\n  private completeTransitions_() {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  }\n\n  get snapshot(): UploadTaskSnapshot {\n    const externalState =\n        fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n    return new UploadTaskSnapshot(\n        this.transferred_, this.blob_.size(), externalState, this.metadata_,\n        this, this.ref_);\n  }\n\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  on(type: TaskEvent, nextOrObserver = undefined, error = undefined,\n     completed = undefined): Unsubscribe | Subscribe<UploadTaskSnapshot> {\n    function typeValidator(_p: any) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw `Expected one of the event types: [${TaskEvent.STATE_CHANGED}].`;\n      }\n    }\n    const nextOrObserverMessage =\n        'Expected a function or an Object with one of ' +\n        '`next`, `error`, `complete` properties.';\n    const nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    const observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p: any) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {\n      }\n      try {\n        observerValidator(p);\n        const anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) ||\n            typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    const specs = [\n      fbsArgs.stringSpec(typeValidator),\n      fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n      fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)\n    ];\n    fbsArgs.validate('on', specs, arguments);\n    const self = this;\n\n    function makeBinder(specs: ArgSpec[]|null): Subscribe<UploadTaskSnapshot> {\n      function binder(\n          nextOrObserver: NextFn<UploadTaskSnapshot> | {[name: string]: string|null} | null,\n          error?: ErrorFn | null,\n          opt_complete?: CompleteFn | null) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        const observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return () => {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p: any) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    const binderSpecs = [\n      fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n      fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)\n    ];\n    const typeOnly =\n        !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) ||\n          typeUtils.isJustDef(completed));\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  }\n\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   *     The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  then<U>(onFulfilled?: ((value: UploadTaskSnapshot) => U | PromiseLike<U>) | null, onRejected?: ((error: any) => U | PromiseLike<U>) | null): Promise<U> {\n      return this.promise_.then<U>(\n        (onFulfilled as (value: UploadTaskSnapshot) => U | PromiseLike<U>),\n        (onRejected as ((error: any) => PromiseLike<U>) | null));\n  }\n\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  catch<T>(onRejected: (p1: Error) => T | PromiseLike<T>): Promise<T> {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * Adds the given observer.\n   */\n  private addObserver_(observer: Observer<UploadTaskSnapshot>) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  }\n\n  /**\n   * Removes the given observer.\n   */\n  private removeObserver_(observer: Observer<UploadTaskSnapshot>) {\n    fbsArray.remove(this.observers_, observer);\n  }\n\n  private notifyObservers_() {\n    this.finishPromise_();\n    const observers = fbsArray.clone(this.observers_);\n    observers.forEach((observer) => {\n      this.notifyObserver_(observer);\n    });\n  }\n\n  private finishPromise_() {\n    if (this.resolve_ !== null) {\n      let triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          const toCall = (this.reject_ as ((p1: Error) => void));\n          fbsAsync(toCall.bind(null, (this.error_ as Error)))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  }\n\n  private notifyObserver_(observer: Observer<UploadTaskSnapshot>) {\n    const externalState =\n        fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, (this.error_ as Error)))();\n        }\n        break;\n      default:\n\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, (this.error_ as Error)))();\n        }\n    }\n  }\n\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  resume(): boolean {\n    fbsArgs.validate('resume', [], arguments);\n    const valid = this.state_ === InternalTaskState.PAUSED ||\n        this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  }\n\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  pause(): boolean {\n    fbsArgs.validate('pause', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  }\n\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  cancel(): boolean {\n    fbsArgs.validate('cancel', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING ||\n        this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  }\n}\n"]}},"hash":"de2d358ef056af13a6c14e74d12f73f4","cacheData":{"env":{}}}