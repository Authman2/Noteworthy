{"id":"../../../../../node_modules/firebase/messaging/controllers/sw-controller.js","dependencies":[{"name":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/sw-controller.js.map","includedInParent":true,"mtime":1494998757000},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/package.json","includedInParent":true,"mtime":1549253646323},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/.babelrc","includedInParent":true,"mtime":1549225258658},{"name":"/Users/adeolauthman/node_modules/firebase/package.json","includedInParent":true,"mtime":1495915167000},{"name":"./controller-interface","loc":{"line":30,"column":35},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/sw-controller.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/controller-interface.js"},{"name":"../models/errors","loc":{"line":34,"column":22},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/sw-controller.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/models/errors.js"},{"name":"../models/worker-page-message","loc":{"line":38,"column":33},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/sw-controller.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/models/worker-page-message.js"},{"name":"../models/fcm-details","loc":{"line":42,"column":26},"parent":"/Users/adeolauthman/node_modules/firebase/messaging/controllers/sw-controller.js","resolved":"/Users/adeolauthman/node_modules/firebase/messaging/models/fcm-details.js"}],"generated":{"js":"/*! @license Firebase v4.0.0\nBuild: rev-c054dab\nTerms: https://firebase.google.com/terms/ */\n\n/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _controllerInterface = require('./controller-interface');\n\nvar _controllerInterface2 = _interopRequireDefault(_controllerInterface);\n\nvar _errors = require('../models/errors');\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _workerPageMessage = require('../models/worker-page-message');\n\nvar _workerPageMessage2 = _interopRequireDefault(_workerPageMessage);\n\nvar _fcmDetails = require('../models/fcm-details');\n\nvar _fcmDetails2 = _interopRequireDefault(_fcmDetails);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FCM_MSG = 'FCM_MSG';\n\nvar SWController = function (_ControllerInterface) {\n    _inherits(SWController, _ControllerInterface);\n\n    function SWController(app) {\n        _classCallCheck(this, SWController);\n\n        var _this = _possibleConstructorReturn(this, (SWController.__proto__ || Object.getPrototypeOf(SWController)).call(this, app));\n\n        self.addEventListener('push', function (e) {\n            return _this.onPush_(e);\n        }, false);\n        self.addEventListener('pushsubscriptionchange', function (e) {\n            return _this.onSubChange_(e);\n        }, false);\n        self.addEventListener('notificationclick', function (e) {\n            return _this.onNotificationClick_(e);\n        }, false);\n        /**\n         * @private\n         * @type {function(Object)|null}\n         */\n        _this.bgMessageHandler_ = null;\n        return _this;\n    }\n    /**\n    * A handler for push events that shows notifications based on the content of\n    * the payload.\n    *\n    * The payload must be a JSON-encoded Object with a `notification` key. The\n    * value of the `notification` property will be used as the NotificationOptions\n    * object passed to showNotification. Additionally, the `title` property of the\n    * notification object will be used as the title.\n    *\n    * If there is no notification data in the payload then no notification will be\n    * shown.\n    * @private\n    */\n\n\n    _createClass(SWController, [{\n        key: 'onPush_',\n        value: function onPush_(event) {\n            var _this2 = this;\n\n            var msgPayload = void 0;\n            try {\n                msgPayload = event.data.json();\n            } catch (err) {\n                // Not JSON so not an FCM message\n                return;\n            }\n            var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {\n                if (hasVisibleClients) {\n                    // Do not need to show a notification.\n                    if (msgPayload.notification || _this2.bgMessageHandler_) {\n                        // Send to page\n                        return _this2.sendMessageToWindowClients_(msgPayload);\n                    }\n                    return;\n                }\n                var notificationDetails = _this2.getNotificationData_(msgPayload);\n                if (notificationDetails) {\n                    var notificationTitle = notificationDetails.title || '';\n                    return self.registration.showNotification(notificationTitle, notificationDetails);\n                } else if (_this2.bgMessageHandler_) {\n                    return _this2.bgMessageHandler_(msgPayload);\n                }\n            });\n            event.waitUntil(handleMsgPromise);\n        }\n        /**\n        * @private\n        */\n\n    }, {\n        key: 'onSubChange_',\n        value: function onSubChange_(event) {\n            var _this3 = this;\n\n            var promiseChain = this.getToken().then(function (token) {\n                if (!token) {\n                    // We can't resubscribe if we don't have an FCM token for this scope.\n                    throw _this3.errorFactory_.create(_errors2.default.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);\n                }\n                var tokenDetails = null;\n                var tokenManager = _this3.getTokenManager();\n                return tokenManager.getTokenDetailsFromToken(token).then(function (details) {\n                    tokenDetails = details;\n                    if (!tokenDetails) {\n                        throw _this3.errorFactory_.create(_errors2.default.codes.INVALID_SAVED_TOKEN);\n                    }\n                    // Attempt to get a new subscription\n                    return self.registration.pushManager.subscribe(_fcmDetails2.default.SUBSCRIPTION_OPTIONS);\n                }).then(function (newSubscription) {\n                    // Send new subscription to FCM.\n                    return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);\n                }).catch(function (err) {\n                    // The best thing we can do is log this to the terminal so\n                    // developers might notice the error.\n                    return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () {\n                        throw _this3.errorFactory_.create(_errors2.default.codes.UNABLE_TO_RESUBSCRIBE, {\n                            'message': err\n                        });\n                    });\n                });\n            });\n            event.waitUntil(promiseChain);\n        }\n        /**\n        * @private\n        */\n\n    }, {\n        key: 'onNotificationClick_',\n        value: function onNotificationClick_(event) {\n            var _this4 = this;\n\n            if (!(event.notification && event.notification.data && event.notification.data[FCM_MSG])) {\n                // Not an FCM notification, do nothing.\n                return;\n            }\n            // Prevent other listeners from receiving the event\n            event.stopImmediatePropagation();\n            event.notification.close();\n            var msgPayload = event.notification.data[FCM_MSG];\n            var clickAction = msgPayload['notification']['click_action'];\n            if (!clickAction) {\n                // Nothing to do.\n                return;\n            }\n            var promiseChain = this.getWindowClient_(clickAction).then(function (windowClient) {\n                if (!windowClient) {\n                    // Unable to find window client so need to open one.\n                    return self.clients.openWindow(clickAction);\n                }\n                return windowClient;\n            }).then(function (windowClient) {\n                if (!windowClient) {\n                    // Window Client will not be returned if it's for a third party origin.\n                    return;\n                }\n                // Delete notification data from payload before sending to the page.\n                msgPayload['notification'];\n\n                delete msgPayload['notification'];\n                var internalMsg = _workerPageMessage2.default.createNewMsg(_workerPageMessage2.default.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload);\n                // Attempt to send a message to the client to handle the data\n                // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n                return _this4.attemptToMessageClient_(windowClient, internalMsg);\n            });\n            event.waitUntil(promiseChain);\n        }\n        /**\n         * @private\n         * @param {Object} msgPayload\n         * @return {NotificationOptions|undefined}\n         */\n\n    }, {\n        key: 'getNotificationData_',\n        value: function getNotificationData_(msgPayload) {\n            if (!msgPayload) {\n                return;\n            }\n            if (_typeof(msgPayload.notification) !== 'object') {\n                return;\n            }\n            var notificationInformation = Object.assign({}, msgPayload.notification);\n            // Put the message payload under FCM_MSG name so we can identify the\n            // notification as being an FCM notification vs a notification from\n            // somewhere else (i.e. normal web push or developer generated\n            // notification).\n            notificationInformation['data'] = _defineProperty({}, FCM_MSG, msgPayload);\n            return notificationInformation;\n        }\n        /**\n         * Calling setBackgroundMessageHandler will opt in to some specific\n         * behaviours.\n         * 1.) If a notification doesn't need to be shown due to a window already\n         * being visible, then push messages will be sent to the page.\n         * 2.) If a notification needs to be shown, and the message contains no\n         * notification data this method will be called\n         * and the promise it returns will be passed to event.waitUntil.\n         * If you do not set this callback then all push messages will let and the\n         * developer can handle them in a their own 'push' event callback\n         * @export\n         * @param {function(Object)} callback The callback to be called when a push\n         * message is received and a notification must be shown. The callback will\n         * be given the data from the push message.\n         */\n\n    }, {\n        key: 'setBackgroundMessageHandler',\n        value: function setBackgroundMessageHandler(callback) {\n            if (callback && typeof callback !== 'function') {\n                throw this.errorFactory_.create(_errors2.default.codes.BG_HANDLER_FUNCTION_EXPECTED);\n            }\n            this.bgMessageHandler_ = callback;\n        }\n        /**\n         * @private\n         * @param {string} url The URL to look for when focusing a client.\n         * @return {Object} Returns an existing window client or a newly opened\n         * WindowClient.\n         */\n\n    }, {\n        key: 'getWindowClient_',\n        value: function getWindowClient_(url) {\n            // Use URL to normalize the URL when comparing to windowClients.\n            // This at least handles whether to include trailing slashes or not\n            var parsedURL = new URL(url).href;\n            return self.clients.matchAll({\n                type: 'window',\n                includeUncontrolled: true\n            }).then(function (clientList) {\n                var suitableClient = null;\n                for (var i = 0; i < clientList.length; i++) {\n                    var parsedClientUrl = new URL(clientList[i].url).href;\n                    if (parsedClientUrl === parsedURL) {\n                        suitableClient = clientList[i];\n                        break;\n                    }\n                }\n                if (suitableClient) {\n                    suitableClient.focus();\n                    return suitableClient;\n                }\n            });\n        }\n        /**\n         * This message will attempt to send the message to a window client.\n         * @private\n         * @param {Object} client The WindowClient to send the message to.\n         * @param {Object} message The message to send to the client.\n         * @returns {Promise} Returns a promise that resolves after sending the\n         * message. This does not guarantee that the message was successfully\n         * received.\n         */\n\n    }, {\n        key: 'attemptToMessageClient_',\n        value: function attemptToMessageClient_(client, message) {\n            var _this5 = this;\n\n            return new Promise(function (resolve, reject) {\n                if (!client) {\n                    return reject(_this5.errorFactory_.create(_errors2.default.codes.NO_WINDOW_CLIENT_TO_MSG));\n                }\n                client.postMessage(message);\n                resolve();\n            });\n        }\n        /**\n         * @private\n         * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n         * this method will resolve to true, otherwise false.\n         */\n\n    }, {\n        key: 'hasVisibleClients_',\n        value: function hasVisibleClients_() {\n            return self.clients.matchAll({\n                type: 'window',\n                includeUncontrolled: true\n            }).then(function (clientList) {\n                return clientList.some(function (client) {\n                    return client.visibilityState === 'visible';\n                });\n            });\n        }\n        /**\n         * @private\n         * @param {Object} msgPayload The data from the push event that should be sent\n         * to all available pages.\n         * @returns {Promise} Returns a promise that resolves once the message\n         * has been sent to all WindowClients.\n         */\n\n    }, {\n        key: 'sendMessageToWindowClients_',\n        value: function sendMessageToWindowClients_(msgPayload) {\n            var _this6 = this;\n\n            return self.clients.matchAll({\n                type: 'window',\n                includeUncontrolled: true\n            }).then(function (clientList) {\n                var internalMsg = _workerPageMessage2.default.createNewMsg(_workerPageMessage2.default.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);\n                return Promise.all(clientList.map(function (client) {\n                    return _this6.attemptToMessageClient_(client, internalMsg);\n                }));\n            });\n        }\n        /**\n         * This will register the default service worker and return the registration.\n         * @private\n         * @return {Promise<!ServiceWorkerRegistration>} The service worker\n         * registration to be used for the push service.\n         */\n\n    }, {\n        key: 'getSWRegistration_',\n        value: function getSWRegistration_() {\n            return Promise.resolve(self.registration);\n        }\n    }]);\n\n    return SWController;\n}(_controllerInterface2.default);\n\nexports.default = SWController;\nmodule.exports = exports['default'];\n\n","map":{"version":3,"sources":["src/messaging/controllers/sw-controller.ts"],"names":["FCM_MSG","SWController","app","self","addEventListener","onPush_","e","onSubChange_","onNotificationClick_","bgMessageHandler_","event","msgPayload","data","json","err","handleMsgPromise","hasVisibleClients_","then","hasVisibleClients","notification","sendMessageToWindowClients_","notificationDetails","getNotificationData_","notificationTitle","title","registration","showNotification","waitUntil","promiseChain","getToken","token","errorFactory_","create","codes","NO_FCM_TOKEN_FOR_RESUBSCRIBE","tokenDetails","tokenManager","getTokenManager","getTokenDetailsFromToken","details","INVALID_SAVED_TOKEN","pushManager","subscribe","SUBSCRIPTION_OPTIONS","subscribeToFCM","fcmSenderId","newSubscription","fcmPushSet","catch","deleteToken","fcmToken","UNABLE_TO_RESUBSCRIBE","stopImmediatePropagation","close","clickAction","getWindowClient_","windowClient","clients","openWindow","internalMsg","createNewMsg","TYPES_OF_MSG","NOTIFICATION_CLICKED","attemptToMessageClient_","notificationInformation","Object","assign","callback","BG_HANDLER_FUNCTION_EXPECTED","url","parsedURL","URL","href","matchAll","type","includeUncontrolled","suitableClient","i","clientList","length","parsedClientUrl","focus","client","message","Promise","resolve","reject","NO_WINDOW_CLIENT_TO_MSG","postMessage","some","visibilityState","PUSH_MSG_RECEIVED","all","map"],"mappings":"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","file":"sw-controller.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport FCMDetails from '../models/fcm-details';\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport default class SWController extends ControllerInterface {\n\n  private bgMessageHandler_: (input: Object) => Promise<any>;\n\n  constructor(app) {\n    super(app);\n\n    self.addEventListener('push', e => this.onPush_(e), false);\n    self.addEventListener(\n        'pushsubscriptionchange', e => this.onSubChange_(e), false);\n    self.addEventListener(\n        'notificationclick', e => this.onNotificationClick_(e), false);\n\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n    this.bgMessageHandler_ = null;\n  }\n\n  /**\n  * A handler for push events that shows notifications based on the content of\n  * the payload.\n  *\n  * The payload must be a JSON-encoded Object with a `notification` key. The\n  * value of the `notification` property will be used as the NotificationOptions\n  * object passed to showNotification. Additionally, the `title` property of the\n  * notification object will be used as the title.\n  *\n  * If there is no notification data in the payload then no notification will be\n  * shown.\n  * @private\n  */\n  onPush_(event) {\n    let msgPayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const handleMsgPromise = this.hasVisibleClients_()\n    .then(hasVisibleClients => {\n      if (hasVisibleClients) {\n        // Do not need to show a notification.\n        if (msgPayload.notification || this.bgMessageHandler_) {\n          // Send to page\n          return this.sendMessageToWindowClients_(msgPayload);\n        }\n        return;\n      }\n\n      const notificationDetails = this.getNotificationData_(msgPayload);\n      if (notificationDetails) {\n        const notificationTitle = notificationDetails.title || '';\n        return (self as any).registration\n          .showNotification(notificationTitle, notificationDetails);\n      } else if (this.bgMessageHandler_) {\n        return this.bgMessageHandler_(msgPayload);\n      }\n    });\n\n    event.waitUntil(handleMsgPromise);\n  }\n\n  /**\n  * @private\n  */\n  onSubChange_(event) {\n    const promiseChain = this.getToken()\n      .then(token => {\n        if (!token) {\n          // We can't resubscribe if we don't have an FCM token for this scope.\n          throw this.errorFactory_.create(\n              Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);\n        }\n\n        let tokenDetails = null;\n        const tokenManager = this.getTokenManager();\n        return tokenManager.getTokenDetailsFromToken(token)\n        .then(details => {\n          tokenDetails = details;\n          if (!tokenDetails) {\n            throw this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);\n          }\n\n          // Attempt to get a new subscription\n          return (self as any).registration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n        })\n        .then(newSubscription => {\n          // Send new subscription to FCM.\n          return tokenManager.subscribeToFCM(\n            tokenDetails.fcmSenderId,\n            newSubscription,\n            tokenDetails.fcmPushSet\n          );\n        })\n        .catch(err => {\n          // The best thing we can do is log this to the terminal so\n          // developers might notice the error.\n          return tokenManager.deleteToken(tokenDetails.fcmToken)\n          .then(() => {\n            throw this.errorFactory_.create(\n              Errors.codes.UNABLE_TO_RESUBSCRIBE, {\n                'message': err\n              }\n            );\n          });\n        });\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n  * @private\n  */\n  onNotificationClick_(event) {\n    if (!(event.notification && event.notification.data &&\n        event.notification.data[FCM_MSG])) {\n      // Not an FCM notification, do nothing.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n\n    event.notification.close();\n\n    const msgPayload = event.notification.data[FCM_MSG];\n    const clickAction = msgPayload['notification']['click_action'];\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    const promiseChain = this.getWindowClient_(clickAction)\n    .then(windowClient => {\n      if (!windowClient) {\n        // Unable to find window client so need to open one.\n        return (self as any).clients.openWindow(clickAction);\n      }\n      return windowClient;\n    })\n    .then(windowClient => {\n      if (!windowClient) {\n        // Window Client will not be returned if it's for a third party origin.\n        return;\n      }\n\n      // Delete notification data from payload before sending to the page.\n      const notificationData = msgPayload['notification'];\n      delete msgPayload['notification'];\n\n      const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED,\n          msgPayload);\n      // Attempt to send a message to the client to handle the data\n      // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n      return this.attemptToMessageClient_(windowClient, internalMsg);\n    });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n  getNotificationData_(msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation = Object.assign({}, msgPayload.notification);\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation['data'] = {\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n  setBackgroundMessageHandler(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw this.errorFactory_.create(\n        Errors.codes.BG_HANDLER_FUNCTION_EXPECTED);\n    }\n\n    this.bgMessageHandler_ = callback;\n  }\n\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n  getWindowClient_(url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url).href;\n\n    return (self as any).clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    })\n    .then(clientList => {\n      let suitableClient = null;\n      for (let i = 0; i < clientList.length; i++) {\n        const parsedClientUrl = new URL(clientList[i].url).href;\n        if (parsedClientUrl === parsedURL) {\n          suitableClient = clientList[i];\n          break;\n        }\n      }\n\n      if (suitableClient) {\n        suitableClient.focus();\n        return suitableClient;\n      }\n    });\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n  attemptToMessageClient_(client, message) {\n    return new Promise((resolve, reject) => {\n      if (!client) {\n        return reject(this.errorFactory_.create(\n          Errors.codes.NO_WINDOW_CLIENT_TO_MSG));\n      }\n\n      client.postMessage(message);\n      resolve();\n    });\n  }\n\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n  hasVisibleClients_() {\n    return (self as any).clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    })\n    .then(clientList => {\n      return clientList.some(client => client.visibilityState === 'visible');\n    });\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n  sendMessageToWindowClients_(msgPayload) {\n    return (self as any).clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    })\n    .then(clientList => {\n      const internalMsg = WorkerPageMessage.createNewMsg(\n        WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED,\n        msgPayload);\n\n      return Promise.all(\n        clientList.map(client => {\n          return this.attemptToMessageClient_(client, internalMsg);\n        })\n      );\n    });\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    return Promise.resolve((self as any).registration);\n  }\n}\n"]}},"hash":"2e1ee33884095dcb7df8f4a03cc50763","cacheData":{"env":{}}}