{"id":"../../../../../node_modules/firebase/storage/implementation/authwrapper.js","dependencies":[{"name":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js.map","includedInParent":true,"mtime":1494998757000},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/package.json","includedInParent":true,"mtime":1549253646323},{"name":"/Users/adeolauthman/Documents/AdeolasCodingStuff/WebDevelopment/Noteworthy/.babelrc","includedInParent":true,"mtime":1549225258658},{"name":"/Users/adeolauthman/node_modules/firebase/package.json","includedInParent":true,"mtime":1495915167000},{"name":"./constants","loc":{"line":14,"column":25},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/constants.js"},{"name":"./error","loc":{"line":18,"column":22},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/error.js"},{"name":"./failrequest","loc":{"line":22,"column":27},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/failrequest.js"},{"name":"./location","loc":{"line":24,"column":24},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/location.js"},{"name":"./promise_external","loc":{"line":26,"column":32},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/promise_external.js"},{"name":"./requestmap","loc":{"line":30,"column":26},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/requestmap.js"},{"name":"./type","loc":{"line":32,"column":20},"parent":"/Users/adeolauthman/node_modules/firebase/storage/implementation/authwrapper.js","resolved":"/Users/adeolauthman/node_modules/firebase/storage/implementation/type.js"}],"generated":{"js":"/*! @license Firebase v4.0.0\nBuild: rev-c054dab\nTerms: https://firebase.google.com/terms/ */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AuthWrapper = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _constants = require('./constants');\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _error2 = require('./error');\n\nvar errorsExports = _interopRequireWildcard(_error2);\n\nvar _failrequest = require('./failrequest');\n\nvar _location = require('./location');\n\nvar _promise_external = require('./promise_external');\n\nvar promiseimpl = _interopRequireWildcard(_promise_external);\n\nvar _requestmap = require('./requestmap');\n\nvar _type = require('./type');\n\nvar type = _interopRequireWildcard(_type);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nvar AuthWrapper = exports.AuthWrapper = function () {\n    function AuthWrapper(app, maker, requestMaker, service, pool) {\n        _classCallCheck(this, AuthWrapper);\n\n        this.bucket_ = null;\n        this.deleted_ = false;\n        this.app_ = app;\n        if (this.app_ !== null) {\n            var options = this.app_.options;\n            if (type.isDef(options)) {\n                this.bucket_ = AuthWrapper.extractBucket_(options);\n            }\n        }\n        this.storageRefMaker_ = maker;\n        this.requestMaker_ = requestMaker;\n        this.pool_ = pool;\n        this.service_ = service;\n        this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n        this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n        this.requestMap_ = new _requestmap.RequestMap();\n    }\n\n    _createClass(AuthWrapper, [{\n        key: 'getAuthToken',\n        value: function getAuthToken() {\n            // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n            // (b/28673818).\n            if (this.app_ !== null && type.isDef(this.app_.INTERNAL) && type.isDef(this.app_.INTERNAL.getToken)) {\n                return this.app_.INTERNAL.getToken().then(function (response) {\n                    if (response !== null) {\n                        return response.accessToken;\n                    } else {\n                        return null;\n                    }\n                }, function () {\n                    return null;\n                });\n            } else {\n                return promiseimpl.resolve(null);\n            }\n        }\n    }, {\n        key: 'bucket',\n        value: function bucket() {\n            if (this.deleted_) {\n                throw errorsExports.appDeleted();\n            } else {\n                return this.bucket_;\n            }\n        }\n        /**\n         * The service associated with this auth wrapper. Untyped to avoid circular\n         * type dependencies.\n         */\n\n    }, {\n        key: 'service',\n        value: function service() {\n            return this.service_;\n        }\n        /**\n         * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n         * at the given Location.\n         * @param loc The Location.\n         * @return Actually a firebaseStorage.Reference, typing not allowed\n         *     because of circular dependency problems.\n         */\n\n    }, {\n        key: 'makeStorageReference',\n        value: function makeStorageReference(loc) {\n            return this.storageRefMaker_(this, loc);\n        }\n    }, {\n        key: 'makeRequest',\n        value: function makeRequest(requestInfo, authToken) {\n            if (!this.deleted_) {\n                var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n                this.requestMap_.addRequest(request);\n                return request;\n            } else {\n                return new _failrequest.FailRequest(errorsExports.appDeleted());\n            }\n        }\n        /**\n         * Stop running requests and prevent more from being created.\n         */\n\n    }, {\n        key: 'deleteApp',\n        value: function deleteApp() {\n            this.deleted_ = true;\n            this.app_ = null;\n            this.requestMap_.clear();\n        }\n    }, {\n        key: 'maxUploadRetryTime',\n        value: function maxUploadRetryTime() {\n            return this.maxUploadRetryTime_;\n        }\n    }, {\n        key: 'setMaxUploadRetryTime',\n        value: function setMaxUploadRetryTime(time) {\n            this.maxUploadRetryTime_ = time;\n        }\n    }, {\n        key: 'maxOperationRetryTime',\n        value: function maxOperationRetryTime() {\n            return this.maxOperationRetryTime_;\n        }\n    }, {\n        key: 'setMaxOperationRetryTime',\n        value: function setMaxOperationRetryTime(time) {\n            this.maxOperationRetryTime_ = time;\n        }\n    }], [{\n        key: 'extractBucket_',\n        value: function extractBucket_(config) {\n            var bucketString = config[constants.configOption] || null;\n            if (bucketString == null) {\n                return null;\n            }\n            var loc = _location.Location.makeFromBucketSpec(bucketString);\n            return loc.bucket;\n        }\n    }]);\n\n    return AuthWrapper;\n}();\n\n","map":{"version":3,"sources":["src/storage/implementation/authwrapper.ts"],"names":["constants","errorsExports","promiseimpl","type","AuthWrapper","app","maker","requestMaker","service","pool","bucket_","deleted_","app_","options","isDef","extractBucket_","storageRefMaker_","requestMaker_","pool_","service_","maxOperationRetryTime_","defaultMaxOperationRetryTime","maxUploadRetryTime_","defaultMaxUploadRetryTime","requestMap_","INTERNAL","getToken","then","response","accessToken","resolve","appDeleted","loc","requestInfo","authToken","request","addRequest","clear","time","config","bucketString","configOption","makeFromBucketSpec","bucket"],"mappings":"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","file":"authwrapper.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport {Reference} from '../reference';\nimport {Service} from '../service';\nimport * as constants from './constants';\nimport * as errorsExports from './error';\nimport {errors} from './error';\nimport {FailRequest} from './failrequest';\nimport {Location} from './location';\nimport * as promiseimpl from './promise_external';\nimport {Request} from './request';\nimport {RequestInfo} from './requestinfo';\nimport {requestMaker} from './requestmaker';\nimport {RequestMap} from './requestmap';\nimport * as type from './type';\nimport {XhrIoPool} from './xhriopool';\nimport { FirebaseApp, FirebaseAuthTokenData } from \"../../app/firebase_app\";\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nexport class AuthWrapper {\n  private app_: FirebaseApp|null;\n  private bucket_: string|null = null;\n\n  /**\n  maker\n     */\n  private storageRefMaker_:\n      (p1: AuthWrapper, p2: Location) => Reference;\n  private requestMaker_: requestMaker;\n  private pool_: XhrIoPool;\n  private service_: Service;\n  private maxOperationRetryTime_: number;\n  private maxUploadRetryTime_: number;\n  private requestMap_: RequestMap;\n  private deleted_: boolean = false;\n\n  constructor(\n      app: FirebaseApp|null,\n      maker: (p1: AuthWrapper, p2: Location) => Reference,\n      requestMaker: requestMaker, service: Service,\n      pool: XhrIoPool) {\n    this.app_ = app;\n    if (this.app_ !== null) {\n      let options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  private static extractBucket_(config: {[prop: string]: any}): string|null {\n    let bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    let loc: Location = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  }\n\n  getAuthToken(): Promise<string|null> {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (this.app_ !== null && type.isDef(this.app_.INTERNAL) &&\n        type.isDef(this.app_.INTERNAL.getToken)) {\n      return this.app_.INTERNAL.getToken().then(\n          function(response: FirebaseAuthTokenData|null): string|null {\n            if (response !== null) {\n              return response.accessToken;\n            } else {\n              return null;\n            }\n          },\n          function(_error) {\n            return null;\n          });\n    } else {\n      return (promiseimpl.resolve(null) as Promise<string|null>);\n    }\n  }\n\n  bucket(): string|null {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  }\n\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  service(): Service {\n    return this.service_;\n  }\n\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  makeStorageReference(loc: Location): Reference {\n    return this.storageRefMaker_(this, loc);\n  }\n\n  makeRequest<T>(requestInfo: RequestInfo<T>, authToken: string|null): Request<T> {\n    if (!this.deleted_) {\n      let request = this.requestMaker_(\n          requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  }\n\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  deleteApp() {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  }\n\n  maxUploadRetryTime(): number {\n    return this.maxUploadRetryTime_;\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    this.maxUploadRetryTime_ = time;\n  }\n\n  maxOperationRetryTime(): number {\n    return this.maxOperationRetryTime_;\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    this.maxOperationRetryTime_ = time;\n  }\n}\n"]}},"hash":"bf5bc93a3c84007606f140a71edcb006","cacheData":{"env":{}}}